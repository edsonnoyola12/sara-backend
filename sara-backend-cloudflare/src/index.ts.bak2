import { WhatsAppHandler } from './handlers/whatsapp';
import { SupabaseService } from './services/supabase';
import { OpenAIService } from './services/openai';
import { TwilioService } from './services/twilio';
import { CalendarService } from './services/calendar';

export interface Env {
  SUPABASE_URL: string;
  SUPABASE_ANON_KEY: string;
  GEMINI_API_KEY: string;
  TWILIO_ACCOUNT_SID: string;
  TWILIO_AUTH_TOKEN: string;
  TWILIO_PHONE_NUMBER: string;
  GOOGLE_SERVICE_ACCOUNT_EMAIL: string;
  GOOGLE_PRIVATE_KEY: string;
  GOOGLE_CALENDAR_ID: string;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    const supabase = new SupabaseService(env.SUPABASE_URL, env.SUPABASE_ANON_KEY);
    const openai = new OpenAIService(env.GEMINI_API_KEY);
    const twilio = new TwilioService(
      env.TWILIO_ACCOUNT_SID,
      env.TWILIO_AUTH_TOKEN,
      env.TWILIO_PHONE_NUMBER
    );
    const calendar = new CalendarService(
      env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
      env.GOOGLE_PRIVATE_KEY,
      env.GOOGLE_CALENDAR_ID
    );

    const whatsappHandler = new WhatsAppHandler(supabase, openai, twilio, calendar);

    // WhatsApp Webhook - Respuesta vacía para que Twilio no envíe nada
    if (url.pathname === '/webhook/whatsapp' && request.method === 'POST') {
      try {
        const formData = await request.formData();
        const body = Object.fromEntries(formData);
        await whatsappHandler.handleIncomingMessage(body);
        
        // Respuesta vacía - NO enviar "OK"
        return new Response('', { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      } catch (error: any) {
        console.error('Webhook Error:', error);
        // Incluso en error, respuesta vacía
        return new Response('', { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
    }

    // API: Get all leads
    if (url.pathname === '/api/leads' && request.method === 'GET') {
      const { data, error } = await supabase.client
        .from('leads')
        .select('*')
        .order('created_at', { ascending: false });

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get lead by ID
    if (url.pathname.match(/^\/api\/leads\/[^\/]+$/) && request.method === 'GET') {
      const id = url.pathname.split('/').pop();
      const { data } = await supabase.client
        .from('leads')
        .select('*')
        .eq('id', id)
        .single();

      return new Response(JSON.stringify(data || {}), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Update lead
    if (url.pathname.match(/^\/api\/leads\/[^\/]+$/) && request.method === 'PUT') {
      const id = url.pathname.split('/').pop();
      const body = await request.json();
      
      const { data, error } = await supabase.client
        .from('leads')
        .update(body)
        .eq('id', id)
        .select()
        .single();

      return new Response(JSON.stringify(data || {}), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get dashboard KPIs
    if (url.pathname === '/api/dashboard/kpis' && request.method === 'GET') {
      const { data: leads } = await supabase.client
        .from('leads')
        .select('*');

      const kpis = {
        total: leads?.length || 0,
        new: leads?.filter(l => l.status === 'new').length || 0,
        contacted: leads?.filter(l => l.status === 'contacted').length || 0,
        qualified: leads?.filter(l => l.status === 'qualified').length || 0,
        appointment_scheduled: leads?.filter(l => l.status === 'appointment_scheduled').length || 0,
        converted: leads?.filter(l => l.status === 'converted').length || 0
      };

      return new Response(JSON.stringify(kpis), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get properties
    if (url.pathname === '/api/properties' && request.method === 'GET') {
      const { data } = await supabase.client
        .from('properties')
        .select('*')
        .order('created_at', { ascending: false });

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get team members
    if (url.pathname === '/api/team' && request.method === 'GET') {
      const { data } = await supabase.client
        .from('team_members')
        .select('*')
        .order('name', { ascending: true });

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    return new Response('SARA Backend', { headers: corsHeaders });

    // API: Generate property video
    if (url.pathname === '/api/videos/generate' && request.method === 'POST') {
      try {
        const body = await request.json();
        const { propertyId, clientName } = body;

        // Obtener propiedad
        const { data: property, error } = await supabase.client
          .from('properties')
          .select('*')
          .eq('id', propertyId)
          .single();

        if (error || !property) {
          return new Response(
            JSON.stringify({ error: 'Propiedad no encontrada' }),
            { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }

        const videoPrompt = `Video de ${property.name} para ${clientName}`;
        
        return new Response(
          JSON.stringify({
            success: true,
            property: property.name,
            clientName: clientName,
            status: 'Video generation ready',
            prompt: videoPrompt,
            message: 'Endpoint configurado - Veo 3 listo para integración'
          }),
          { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );

      } catch (error: any) {
        return new Response(
          JSON.stringify({ error: error.message }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
    }

    return new Response('SARA Backend', { headers: corsHeaders });
  },
};
