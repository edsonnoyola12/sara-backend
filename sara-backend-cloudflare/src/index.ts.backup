import { WhatsAppHandler } from './handlers/whatsapp';
import { SupabaseService } from './services/supabase';
import { OpenAIService } from './services/openai';
import { TwilioService } from './services/twilio';
import { CalendarService } from './services/calendar';

export interface Env {
  SUPABASE_URL: string;
  SUPABASE_ANON_KEY: string;
  GEMINI_API_KEY: string;
  TWILIO_ACCOUNT_SID: string;
  TWILIO_AUTH_TOKEN: string;
  TWILIO_PHONE_NUMBER: string;
  GOOGLE_SERVICE_ACCOUNT_EMAIL: string;
  GOOGLE_PRIVATE_KEY: string;
  GOOGLE_CALENDAR_ID: string;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    const supabase = new SupabaseService(env.SUPABASE_URL, env.SUPABASE_ANON_KEY);
    const openai = new OpenAIService(env.GEMINI_API_KEY);
    const twilio = new TwilioService(
      env.TWILIO_ACCOUNT_SID,
      env.TWILIO_AUTH_TOKEN,
      env.TWILIO_PHONE_NUMBER
    );
    const calendar = new CalendarService(
      env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
      env.GOOGLE_PRIVATE_KEY,
      env.GOOGLE_CALENDAR_ID
    );

    const whatsappHandler = new WhatsAppHandler(supabase, openai, twilio, calendar);

    // WhatsApp Webhook - Respuesta vacía para que Twilio no envíe nada
    if (url.pathname === '/webhook/whatsapp' && request.method === 'POST') {
      try {
        const formData = await request.formData();
        const body = Object.fromEntries(formData);
        await whatsappHandler.handleIncomingMessage(body);
        
        // Respuesta vacía - NO enviar "OK"
        return new Response('', { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      } catch (error: any) {
        console.error('Webhook Error:', error);
        // Incluso en error, respuesta vacía
        return new Response('', { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      }
    }

    // API: Get all leads
    if (url.pathname === '/api/leads' && request.method === 'GET') {
      const { data, error } = await supabase.client
        .from('leads')
        .select('*')
        .order('created_at', { ascending: false });

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get lead by ID
    if (url.pathname.match(/^\/api\/leads\/[^\/]+$/) && request.method === 'GET') {
      const id = url.pathname.split('/').pop();
      const { data } = await supabase.client
        .from('leads')
        .select('*')
        .eq('id', id)
        .single();

      return new Response(JSON.stringify(data || {}), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Update lead
    if (url.pathname.match(/^\/api\/leads\/[^\/]+$/) && request.method === 'PUT') {
      const id = url.pathname.split('/').pop();
      const body = await request.json();
      
      const { data, error } = await supabase.client
        .from('leads')
        .update(body)
        .eq('id', id)
        .select()
        .single();

      return new Response(JSON.stringify(data || {}), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get dashboard KPIs
    if (url.pathname === '/api/dashboard/kpis' && request.method === 'GET') {
      const { data: leads } = await supabase.client
        .from('leads')
        .select('*');

      const kpis = {
        total: leads?.length || 0,
        new: leads?.filter(l => l.status === 'new').length || 0,
        contacted: leads?.filter(l => l.status === 'contacted').length || 0,
        qualified: leads?.filter(l => l.status === 'qualified').length || 0,
        appointment_scheduled: leads?.filter(l => l.status === 'appointment_scheduled').length || 0,
        converted: leads?.filter(l => l.status === 'converted').length || 0
      };

      return new Response(JSON.stringify(kpis), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get properties
    if (url.pathname === '/api/properties' && request.method === 'GET') {
      const { data } = await supabase.client
        .from('properties')
        .select('*')
        .order('created_at', { ascending: false });

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get team members
    if (url.pathname === '/api/team' && request.method === 'GET') {
      const { data } = await supabase.client
        .from('team_members')
        .select('*')
        .order('name', { ascending: true });

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }



    // API: Generate property video with Veo 3
    if (url.pathname === '/api/videos/generate' && request.method === 'POST') {
      try {
        const body = await request.json();
        const { propertyId, clientName } = body;

        // Obtener propiedad completa
        const { data: property, error } = await supabase.client
          .from('properties')
          .select('*')
          .eq('id', propertyId)
          .single();

        if (error || !property) {
          return new Response(
            JSON.stringify({ error: 'Propiedad no encontrada' }),
            { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }

        // Importar y usar el servicio Veo3
        const { generatePropertyVideo } = await import('./services/veo3Service');
        
        const videoData = await generatePropertyVideo(
          property,
          clientName || 'Cliente',
          env.GOOGLE_API_KEY
        );

        // En producción, aquí guardaríamos el video_url en la BD
        // await supabase.client
        //   .from('properties')
        //   .update({ video_url: videoData.videoUrl })
        //   .eq('id', propertyId);

        return new Response(
          JSON.stringify(videoData),
          { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );

      } catch (error: any) {
        return new Response(
          JSON.stringify({ 
            error: error.message,
            details: 'Error generating video with Veo 3'
          }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
    }

    // API: Get all properties
    if (url.pathname === '/api/properties' && request.method === 'GET') {
      const { data, error } = await supabase.client
        .from('properties')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      return new Response(JSON.stringify(data || []), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Get property by ID
    if (url.pathname.startsWith('/api/properties/') && request.method === 'GET') {
      const id = url.pathname.split('/')[3];
      
      const { data, error } = await supabase.client
        .from('properties')
        .select('*')
        .eq('id', id)
        .single();

      if (error || !data) {
        return new Response(JSON.stringify({ error: 'Property not found' }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      return new Response(JSON.stringify(data), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // API: Create property
    if (url.pathname === '/api/properties' && request.method === 'POST') {
      try {
        const body = await request.json();
        
        const { data, error } = await supabase.client
          .from('properties')
          .insert([body])
          .select()
          .single();

        if (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        return new Response(JSON.stringify(data), {
          status: 201,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error: any) {
        return new Response(JSON.stringify({ error: error.message }), {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // API: Update property
    if (url.pathname.startsWith('/api/properties/') && request.method === 'PUT') {
      try {
        const id = url.pathname.split('/')[3];
        const body = await request.json();
        
        const { data, error } = await supabase.client
          .from('properties')
          .update(body)
          .eq('id', id)
          .select()
          .single();

        if (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        return new Response(JSON.stringify(data), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error: any) {
        return new Response(JSON.stringify({ error: error.message }), {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }


    // API: Upload property files (photos/brochures)
    if (url.pathname === '/api/properties/upload' && request.method === 'POST') {
      try {
        const formData = await request.formData();
        const file = formData.get('file');
        const propertyId = formData.get('propertyId');
        const fileType = formData.get('fileType'); // 'gallery' or 'brochure'

        if (!file || !propertyId) {
          return new Response(JSON.stringify({ error: 'Missing file or propertyId' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Generar nombre único para el archivo
        const timestamp = Date.now();
        const fileName = `${propertyId}/${fileType}/${timestamp}_${file.name}`;

        // Subir a Supabase Storage
        const { data: uploadData, error: uploadError } = await supabase.client.storage
          .from('properties')
          .upload(fileName, file, {
            contentType: file.type,
            upsert: false
          });

        if (uploadError) {
          return new Response(JSON.stringify({ error: uploadError.message }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Obtener URL pública
        const { data: urlData } = supabase.client.storage
          .from('properties')
          .getPublicUrl(fileName);

        const fileUrl = urlData.publicUrl;

        // Actualizar property en BD
        const { data: property } = await supabase.client
          .from('properties')
          .select('gallery_urls, brochure_urls')
          .eq('id', propertyId)
          .single();

        const currentUrls = fileType === 'gallery' 
          ? (property?.gallery_urls || [])
          : (property?.brochure_urls || []);

        const updatedUrls = [...currentUrls, fileUrl];

        const updateField = fileType === 'gallery' ? 'gallery_urls' : 'brochure_urls';
        
        await supabase.client
          .from('properties')
          .update({ [updateField]: updatedUrls })
          .eq('id', propertyId);

        return new Response(JSON.stringify({ 
          success: true, 
          url: fileUrl,
          fileName: fileName 
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });

      } catch (error: any) {
        return new Response(JSON.stringify({ error: error.message }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Automation endpoint
    if (url.pathname === '/api/automation' && request.method === 'POST') {
      const { handleAutomation } = await import('./routes/automation');
      return handleAutomation(request, env);
    }

    return new Response('SARA Backend', { headers: corsHeaders });
  },
};
